# Haskelm: Haskell to Elm Translation

**NEW** More syntax is now supported for translation, including where declarations, As-patterns, newtypes, list-ranges, guarded function bodies and ... records! Mostly. Everything but record-update-syntax is working for Haskell to Elm.

A Version of Elm which supports Haskell to Elm translation, as well as
compilation from within Haskell.

Other than two bug fixes to the pretty-printing functions, Haskelm does not modify
the Elm compiler. It simply adds files. 

Eventually, Haskelm could become a separate library, when the Elm API stabilizes,
but for now it needs access to Elm's AST types.

Learn about the Elm programming language at [elm-lang.org](http://elm-lang.org/).

    
## Install
Haskelm is a modification on Elm. Therefore, it is reccomended that you install it in a Cabal sanbox.
To install the modified library, compiler, and haskelm binary, run

    cabal install

in the directory where you have checkoud the source
You can install only the haskelm executable with 
    cabal install haskelm

    
## Use

To use `haskelm` as a binary, simply run

    haskelm [infile]
Note that infile must contain Haskell declarations, but not imports,
module declarations, etc. (This should change in the near future)

The haskelm binary will print to stdout an Elm translation of the given haskell file.

## Library
You can also use Haskelm within a Haskell program, via Template Haskell.
These functions are delcared in Language.Elm.TH

Currently, you feed TemplateHaskell a list of haskell declarations.
It will then translate them into an Elm string, which is declared as a variable.
Then both the Haskell declarations and the Elm string will be spliced in.

To splice in a quoted list of declarations, use

    $(decHaskAndElm "variableNameForElmString" [d| ... |])

where your Haskell declarations go instide the `[d| ... |]` brackets.

Similarly, you can splice and translate declarations from a String or a file
using 

    $(decsFromString "elmFromString" "data X = Y | Z" )
or
    $(decsFromFile "elmFromFile" "input_file.hs" )

See tests/Tests/TH.hs for an example.

The translated code is intended to be used as a separate Elm module,
in order to avoid namespace conflicts.

## Compiling from within Haskell

The module Language.Elm.BuildString provides a function, `buildAll`,
which takes a list of Elm filename-code pairs. It returns the Javascript
generated by writing the source code

## Translation

Haskelm can currently translate most basic Haskell, including functions, algebraic data types, newtypes, and type synonyms.
Support is now in place for records, guarded-function-bodies, list-ranges, where-declarations, as-patterns, 
and multi-clause function definitions (pattern matching).

Translation of class or instance declarations is not supported, and will not likely be supported in the near future,
as Elm does not support Type classes.

Most GHC extensions are unsupported, with the exception of Multi-Way-If statements,
since they have a direct translation into Elm.

## Json

Haskelm currently derivies toJson and fromJson functions for all Data declarations.
To get around the lack of TypeClasses in Elm, each translated module contains a 
sum type, called BoxedJson, which wraps around any types defined in the module,
as well as lists, integers, floats, bools, and null.

Values of type `FOO` can be boxed using the constructor `BoxedJsonFOO`.
This also applies to `Int`, `Float`, and `String`.
Note that `BoxedJson_List` wraps a list of type `BoxedJson`.

The Haskell versions of these functions wil lbe avaliable soon.

## Disclaimer

This is VERY much a work in progress, and is not production ready.
Please feel free to open issues for any bugs or feature suggestions.